@{
    ViewBag.Title = "C# For Dummies";
    Layout = "~/Views/Shared/_LayoutEN.cshtml";
}

@section ExtraHeadContent {
    <meta name="description" content="C# for Dummies are the poblems from The C# Book of The Telerik Academy, their guidelines and the solutions, which I wrote or tried to :)">
    <meta name="author" content="Ivan Popov">
    <meta name="thumbnail" content="http://localhost:49690/Resources/ivanpopov.jpg" />
    <link rel="image_src" href="http://localhost:49690/Resources/ivanpopov.jpg" />
}

<h1>C# For Dummies</h1>
<h2> Chapter 7. Arrays</h2>
<span class="tab"></span>1. Write a program, which creates an array of <b>20 elements of type integer</b> and initializes each of the elements with a value equals to the index of the element multiplied by 5. Print the elements to the console.<br /><br />
<span class="tab"></span>Guidelines: Use an <code>int[]</code> array and a<code>for</code> loop.<br /><br />
<span class="tab"></span>Solution: <br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%201/Program.cs" target="_blank"><b><u>Link</u></b></a><hr>
<span class="tab"></span>2. Write a program, which <b>reads two arrays</b> from the console and <b>checks whether they are equal</b> (two arrays are equal when they are of equal length and all of their elements, which have the same index, are equal).<br /><br />
<span class="tab"></span>Guidelines: Two arrays are <b>equal</b> if they have the same value for the <b>length</b> and the <b>values for their elements</b>. You can check for the second condition using a for-loop<br /><br />
<span class="tab"></span>Solution: <br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%202/Program.cs" target="_blank"><b><u>Link</u></b></a><hr>
<span class="tab"></span>3. Write a program, which <b>compares two arrays of type char lexicographically</b> (character by character) and checks, which one is first in the lexicographical order.<br /><br />
<span class="tab"></span>Guidelines: In <b>lexicographic order</b> the elements are <b>compared one by one</b> starting from the very left. If the elements are not the same, the array, whose element is <b>smaller</b> (comes earlier in the alphabet), comes first. If the elements are equal, the next character is compared. If the end of one of the arrays is reached, without finding different elements, the shorter array is the smaller (comes earlier lexicographically). If all elements are equal, the arrays are <b>equal</b><br /><br />
<span class="tab"></span>Solution: <br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%203/Program.cs" target="_blank"><b><u>Link</u></b></a><hr>
<span class="tab"></span>4. Write a program, which finds the maximal sequence of consecutive equal elements in an array. <br /><span class="tab"></span>E.g.: {2, 1, 1, 2, 3, 3, <b>2, 2, 2</b>, 1} <span style="font-family: Wingdings;">à</span>  {2, 2, 2}. <br />
<span class="tab"></span><span style="font-family: Wingdings;">à</span> {2, 2, 2}.<br /><br />
<span class="tab"></span>Guidelines: <b>Scan the array from left to right</b>. Every time when the current number is different from the one before it, a <b>new sequence starts</b>. If the current element is equal to the one before it, it is a <b>continuation of the same sequence</b>. So, if we keep the index of the <b>start position</b> of the current sequence (in the beginning it is 0) in <code>start</code> and the <b>length of the current sequence</b> (in the beginning it is 1) in <code>len</code>, we can find all sequences of equal elements and their lengths. We can easily keep the shortest one in two additional variables – <code>bestStart</code> and <code>bestLen</code>.<br /><br />
<span class="tab"></span>Solution: <br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%204/Program.cs" target="_blank"><b><u>Link</u></b></a><hr>
<span class="tab"></span>5. Write a program, which finds the <b>maximal sequence</b> of consecutively placed <b>increasing integers</b>. <br />
<span class="tab"></span>Example: {3, <b>2, 3, 4</b>, 2, 2, 4} <span style="font-family: Wingdings;">à</span>  {2, 3, 4}.<br /><br />
<span class="tab"></span>Guidelines: This exercise is <b>very similar to the previous one</b>, but we have a continuation of the current sequence when <b>the next element is bigger</b>.<br /><br />
<span class="tab"></span>Solution: <br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%205/Program.cs" target="_blank"><b><u>Link</u></b></a><hr>
<span class="tab"></span> 6. Write a program, which finds the <b>maximal sequence of increasing elements</b> in an array <code>arr[n]</code>. It is not necessary the elements to be consecutively placed. <br />
<span class="tab"></span>Example: {9, 6, <b>2</b>, 7, <b>4</b>, 7, <b>6</b>, 5, <b>8</b>, 4} <span style="font-family: Wingdings;">à</span>  {2, 4, 6, 8}.<br /><br />
<span class="tab"></span>Упътване: Guidelines: We can solve the problem with <b>two nested loops</b> and one more array <code>len[0…n-1]</code>. In the array <code>len[i]</code> we can keep the length of the longest consecutively increasing sequence, which starts somewhere in the array (it does not matter where exactly) and ends with the element <code>arr[i]</code>. Therefore <code>len[0]=1, len[x]</code> is the maximal sum <code>max(1 + len[prev])</code>, where <code>prev < x </code> and <code>arr[prev] < arr[x]</code>. Following the definition, we can calculate <code>len[0…n-1]</code> with two nested loops: the <b>outer loop</b> will iterate through the array <b>from left to right with</b> the loop variable <code>x</code>. The <b>inner loop</b> will iterate through the array from the start to position <code>x-1</code> and searches for the element <code>prev</code> with maximal value of <code>len[prev]</code>, where <code>arr[prev] < arr[x] </code>. After the search, we initialize <code>len[x]</code> with 1 + the biggest found value of <code>len[prev]</code> or with 1, if such a value is not found. <br /><span class="tab"></span>The described algorithm <b>finds the lengths of all maximal ascending sequences</b>, which end at each of the elements. The biggest one of these values is the length of the <b>longest increasing sequence</b>. If we need to find <b>the elements themselves</b>, which compose that longest sequence, we can start from the element, where the sequence ends (at index <code>x</code>), we can print it and we can search for a previous element (<code>prev</code>). By definition <code>prev < x </code> and <code>len[x] = 1 + len[prev]</code> so we can find <code>prev</code> with a <code>for</code>-loop from 1 to <code>x-1</code>. After that we can repeat the same for <code>x=prev</code>. By finding and printing the previous element (<code>prev</code>) many times until it exists, we can find <b>the elements, which compose the longest sequence</b> in reversed order (from the last to the first).<br/><br/>
<span class="tab"></span>Solution: <br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%206/Program.cs" target="_blank"><b><u>Link</u></b></a><hr>
<span class="tab"></span>7. Write a program, which reads from the console two integer numbers <b>N</b> and <b>K</b> (K<N) and array of N integers. Find those <b>K consecutive elements</b> in the array, which have <b>maximal sum</b>.<br /><br />
<span class="tab"></span>Guidelines:  <b>Find in Internet information about "Selection sort"</b> and its C# implementations. Briefly the idea is to find the smallest element and to place it at position 0 (through <b>swapping</b>) then to find the smallest number excluding the first and place it at position 1 and so on, until the entire array is arranged in ascending order.<br /><br />
<span class="tab"></span>Solution: <br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%207/Program.cs" target="_blank"><b><u>Link</u></b></a><hr>
<span class="tab"></span>8. <b>Sorting an array</b> means to arrange its elements in an increasing (or decreasing) order. Write a program, which sorts an array using the algorithm "<code>selection sort</code>".<br /><br />
<span class="tab"></span>Guidelines: <b>Find in Internet information about "Selection sort"</b> and its C# implementations. Briefly the idea is to find the smallest element and to place it at position 0 (through <b>swapping</b>) then to find the smallest number excluding the first and place it at position 1 and so on, until the entire array is arranged in ascending order.<br /><br />
<span class="tab"></span>Solution: <br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%208/Program.cs" target="_blank"><b><u>Link</u></b></a><hr>
<span class="tab"></span>9. Write a program, which finds a subsequence of numbers with maximal sum. E.g.: {2, 3, -6, -1, <b>2, -1, 6, 4</b>, -8, 8} <span style="font-family: Wingdings;">à</span>  <b>11</b><br /><br />
<span class="tab"></span>Guidelines: There are <b>two ways</b> to solve this problem. The first way is to use <b>brute force method</b>, which in this case means that using <b>two nested loops</b> we check every possible start and end and its corresponding sum. <br /><span class="tab"></span>The second way is to <b>use one loop through the array</b> to scan it from left to right and sum the elements. Once we get a <b>negative sum</b>, we can <b>restart summing from the next element</b>. Think why this is correct! At each step we check if the current sum is greater than the current max.<br /><br />
<span class="tab"></span>Solution: <br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%209/Program.cs" target="_blank"><b><u>Link</u></b></a><hr>
<span class="tab"></span>10. Write a program, which finds the <b>most frequently occurring</b> element in an array. Example: {<b>4</b>, 1, 1, <b>4</b>, 2, 3, <b>4</b>, <b>4</b>, 1, 2, <b>4</b>, 9, 3} <span style="font-family: Wingdings;">à</span>  4 (5 times).<br /><br />
<span class="tab"></span>Guidelines: This exercise <b>can be solved in a couple of ways</b>. One of them is the following: get the first number and check how many times it is repeated in the array and store this number in a variable. After a repeated number is found we change its value to <code>int.MinValue</code>. Then pass to the <b>next number</b> and do the same with it. The current number is remembered if its occurrences are maximal. As you may guess, when a number equal to <code>int.MinValue</code> is found (already processed number) we should skip it. <br /><span class="tab"></span>Another solution is to <b>sort the numbers</b> in ascending order and then the elements with same value will be placed next to each other. So, basically we then <b>find the longest sequence of neighbor equal elements</b>.<br /><br />
<span class="tab"></span>Solution: <br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%2010/Program.cs" target="_blank"><b><u>Link</u></b></a><hr>
<span class="tab"></span>11. Write a program to find a sequence of neighbor numbers in an array, which has a <b>sum of certain number S</b>. Example: {4, 3, 1, <b>4</b>, <b>2</b>, <b>5</b>, 8}, S=11 <span style="font-family: Wingdings;">à</span>  {4, 2, 5}.<br /><br />
<span class="tab"></span>Guidelines: This exercise can be solved with <b>two nested loops</b>. The <b>first loop</b> assigns a starting index. The <b>second loop</b> sums the elements from the starting index to the right until this partial sum reaches or is greater than <b>S</b>. If the sum is equal to <b>S</b>, we will remember the starting index (from the first loop) and the ending index (from the second loop). <br /><span class="tab"></span>If all numbers are positive, there is a <b>much faster algorithm</b>. We <b>sum all numbers from left to the right</b>, starting from zero. If the current sum becomes greater than <b>S</b> during the summation, we remove the leftmost number in the sequence and we subtract it from the sum. If the current sum is still greater than <b>S</b>, we remove the next leftmost number and do that until the current sum becomes smaller than <b>S</b>. When the sum becomes smaller than <b>S</b> we <b>add the next number on right</b>. If we find a sum equal to <b>S</b>, we print the sum and the sequence to the console. So this solution uses <b>just with one scan</b> through the elements in the array.<br /><br />
<span class="tab"></span>Solution: <br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%2011/Program.cs" target="_blank"><b><u>Link</u></b></a><hr>
<span class="tab"></span>12. Напишете програма, която създава следните квадратни матрици и ги извежда на конзолата във форматиран вид. Размерът на матриците се въвежда от конзолата. <br />
<span class="tab"></span>Example for <code>(4,4)</code>:<br />
<span class="tab"></span><img src="/Resources/CSResources/ch7-12.gif"><br /><br />
<span class="tab"></span>Guidelines: a), b), c) Think about appropriate <b>ways for iterating through the matrices</b> with <b>two nested loops</b>. <br /><span class="tab"></span>d) We can start from (0, 0) and go <b>down N times</b>. Therefore, go to the <b>right N-1 times</b>, after that <b>up N-1 times</b>, after that <b>left N-2 times</b>, after that <b>down N-2 times</b> and etc. At each iteration we place the next number in a sequence 1, 2, 3, …, N in the cell, which we are leaving.<br /><br />
<span class="tab"></span>Solution: <br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%2012/Program.cs" target="_blank"><b><u>Link 12a</u></b></a><br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%2012b/Program.cs" target="_blank"><b><u>Link 12b</u></b></a><br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%2012c/Program.cs" target="_blank"><b><u>Link 12c</u></b></a><br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%2012d/Program.cs" target="_blank"><b><u>Link 12d</u></b></a><hr>
<span class="tab"></span>13. Write a program, which creates a rectangular array with size of <code>n</code> by <code>m</code> elements. The dimensions and the elements should be read from the console. Find a <b>platform with size of (3, 3) with a maximal sum</b>.<br /><br />
<span class="tab"></span>Guidelines: Look at the previous solution.<br /><br />
<span class="tab"></span>Solution: <br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%2013/Program.cs" target="_blank"><b><u>Link</u></b></a><hr>
<span class="tab"></span>14. Write a program, which finds the <b>longest sequence of equal string elements in a matrix</b>. A sequence in a matrix we define as a set of neighbor elements <b>on the same row, column or diagonal</b>.<br /><span class="tab"></span><img src="/Resources/CSResources/ch7-14.jpeg"><br /><br />
<span class="tab"></span>Guidelines: Check every element in a diagonal line, a row and a column until you get a <b>sequence</b>. If you get a sequence, check whether this sequence is longer than the currently longest sequence.<br /><br />
<span class="tab"></span>Solution: <br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%2014/Program.cs" target="_blank"><b><u>Link</u></b></a><hr>
<span class="tab"></span>15. Write a program, which creates an array containing <b>all Latin letters</b>. The user inputs <b>a word</b> from the console and as result the program prints to the console the <b>indices of the letters from the word</b>.<br /><br />
<span class="tab"></span>Guidelines:  We can solve this problem with <b>two nested loops</b> (one for the words and one for the letters of the current word). There is a solution without using an array: we can calculate the index of a given uppercase Latin letter ch using the expression: <code>(int) ch – (int) 'A'</code>.<br /><br />
<span class="tab"></span>Solution: <br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%2015/Program.cs" target="_blank"><b><u>Link</u></b></a><hr>
<span class="tab"></span>16. Write a program, which uses a <b>binary search</b> in a <b>sorted</b> array of integer numbers to find a certain element.<br /><br />
<span class="tab"></span>Guidelines: Find on the Internet information about <b>the algorithm "binary search"</b>. Note that binary search works only on <b>sorted arrays</b>.<br /><br />
<span class="tab"></span>Solution: <br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%2016/Program.cs" target="_blank"><b><u>Link</u></b></a><hr>
<span class="tab"></span>17. Write a program, which sorts an array of integer elements using a "<b>merge sort</b>" algorithm.<br /><br />
<span class="tab"></span>Guidelines: Find on the Internet information about the <b>algorithm "merge sort"</b> and its implementations in C#. It is a bit <b>complicated to write merge sort efficiently</b>. You can have <b>3 preallocated arrays</b> when merging arrays: <b>two arrays for keeping the numbers for merging</b> and а <b>result array</b>. Thus you will never allocate new arrays during the algorithm’s execution. The arrays will be allocated just once at the start and you will just change their purpose (<b>swap them</b>) during the algorithm execution.<br /><br />
<span class="tab"></span>Solution: <br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%2017/Program.cs" target="_blank"><b><u>Link</u></b></a><hr>
<span class="tab"></span>18. Write a program, which sorts an array of integer elements using a "<b>quick sort</b>" algorithm.<br /><br />
<span class="tab"></span>Guidelines: Find information about <b>the "quick sort" algorithm</b> in Internet and its C# implementations. It can be best implemented by using <b>recursion</b>. Generally at each step you choose an element called <b>pivot</b> and reorder the array into two sections: at the <b>left side</b> move all <b>elements ≤ pivot</b> and at the <b>right side</b> move all <b>elements > pivot</b>. Finally <b>run the quicksort algorithm recursively</b> over the left and the right sides.<br /><br />
<span class="tab"></span>Solution: <br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%2018/Program.cs" target="_blank"><b><u>Link</u></b></a><hr>
<span class="tab"></span>19. Write a program, which finds <b>all prime numbers</b> in the range [1…10,000,000].<br /><br />
<span class="tab"></span>Guidelines: Find on the Internet information about "<b>The sieve of Erathostenes</b>" (you have probably heard about it in math classes in high-school).<br /><br />
<span class="tab"></span>Solution: <br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%2019/Program.cs" target="_blank"><b><u>Link</u></b></a><hr>
<span class="tab"></span>20. Write a program, which checks whether there is a <b>subset</b> of given array of <b>N</b> elements, which has a <b>sum S</b>. The numbers <code>N, S</code> and the array values are read from the console. Same number can be used many times. <br />
<span class="tab"></span>Example: {2, 1, 2, 4, 3, 5, 2, 6}, S = 14 <span style="font-family: Wingdings;">à</span> yes (1 + 2 + 5 + 6 = 14)<br /><br />
<span class="tab"></span>Guidelines: <b>Generate all possible sums</b> this way: take all the numbers and mark them as "<b>possible sum</b>". Then take every number <code>ko, k2, …, kn-1</code> and for each already marked "possible sum" <code>p</code>, mark as possible the sum <code>p+ki</code>. If at some step you get <code>S</code>, a solution is found. You can keep track of the "possible sums" either in a <code>bool[]</code> array <code>possible[]</code>, where each index is a possible sum, or in a more complex data structure like <code>Set<int></code>. Once you have <code>possible[S] == true</code>, you can find a number <code>ki</code> such that possible<code>[S-ki] == true</code>, print <code>ki</code> and subtract it from <code>S</code>. Repeat the same to find the next <code>ki</code> and print and subtract is again, until <code>S</code> reaches 0. <br /><span class="tab"></span><b>Another algorithm</b>: generate <b>all possible subsets</b> of the numbers by a <code>for</code>-loop from 0 to <code>2N-1</code>. If we have a number <code>p</code>, take its binary representation (which consists of <b>exactly N bits</b>) and sum the numbers that correspond to 1 in the binary representation of <code>p</code> (with a <b>nested loop</b> from 0 to <code>N-1</code>). Thus all possible sums will be generated and if some of them is <code>S</code>, it can be printed. Note that <b>this algorithm is slow</b> (needs exponential time and cannot run for 100 or 1000 elements). It also does not allow using the same array element twice in the sum.<br /><br />
<span class="tab"></span>Solution: <br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%2020/Program.cs" target="_blank"><b><u>Link</u></b></a><hr>
<span class="tab"></span>21. Write a program which by given <b>N</b> numbers, <b>K</b> and <b>S</b>, finds <b>K</b> elements out of the <b>N</b> numbers, the sum of which is exactly <b>S</b> or says it is not possible. <br /><span class="tab"></span>Example: {3, <b>1</b>, 2, <b>4</b>, <b>9</b>, 6}, <b>S = 14</b>,<b> K = 3</b> <span style="font-family: Wingdings;">à</span> yes (1 + 2 + 4 = 14)<br /><br />
<span class="tab"></span>Solution: <br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%2021/Program.cs" target="_blank"><b><u>Link</u></b></a><hr>
<span class="tab"></span>22. Write a program, which reads an array of integer numbers from the console and <b>removes a minimal number of elements</b> in such a way that <b>the remaining array is sorted</b> in an increasing order. <br /><span class="tab"></span>Example: {6, <b>1</b>, 4, <b>3</b>, 0, <b>3</b>, 6, <b>4</b>, <b>5</b>} <span style="font-family: Wingdings;">à</span>  {1, 3, 3, 4, 5}<br />
<span class="tab"></span>Guidelines: Use <b>dynamic programming</b> to find the <b>longest increasing sub-sequence</b> in the input sequence <code>arr[]</code>. The elements not included in the maximal increasing sequence should be removed in order the array to become sorted.<br /><br />
<span class="tab"></span>Solution: <br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%2022/Program.cs" target="_blank"><b><u>Link</u></b></a><hr>
<span class="tab"></span>23. Write a program, which reads the integer numbers <code>N</code> and <code>K</code> from the console and prints <b>all variations of K elements of the numbers in the interval [1…N]</b>.<br /><span class="tab"></span>Example:  N = 3 <span style="font-family: Wingdings;">à</span>  {1, 2, 3}, {1, 3, 2}, {2, 1, 3}, {2, 3, 1}, {3, 1, 2}, {3, 2, 1}<br /><br />
<span class="tab"></span>Guidelines: Start from the <b>first variation</b> in the lexicographical order: <b>{1, 1, …} K</b> times. Think of this as <b>k-digit number</b>. To <b>obtain the next variation, increase the last digit</b>. If it becomes greater than N, change it to 1 and increase the next digit on the left. Do the same on the left until the first digit goes greater than N.<br /><br />
<span class="tab"></span>Solution: <br />
<span class="tab"></span><a href="https://github.com/ivanpop/CS-for-Dummies/blob/master/Chapter%207%20Solution%2023/Program.cs" target="_blank"><b><u>Link</u></b></a><br /><hr>
<span class="tab"></span><a href="javascript:history.back()">&#8592; Back</a>
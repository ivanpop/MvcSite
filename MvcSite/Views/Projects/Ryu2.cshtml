@{
    Layout = "~/Views/Shared/_Layout.cshtml";
    ViewBag.Title = "Ryu: The Big Adventure!";
}

<h1>Ryu: The Big Adventure!</h1>
<h2>Реализация</h2>
<h3>Play</h3>
<p><span class="tab"></span>Класът Play е основното състояние на играта. В него са реализирани главният герой, враговете му, структурата на нивото, обектите по картата и взаимоотношението между всички тях.</p>
<h4>Начална анимация</h4>
<p><span class="tab"></span>Нивото ни приветства с начална анимация - „Round One“ и съпътстващ я звук. За целта се използва изображение (round1Image) и мащабиращ ефект, като така се добавя допълнителна динамика. За постигане на ефекта се използва командата round1Image.draw() заедно с променливата round1Scale, която отговаря за мащаба на изображението. Когато използваме командата round1Scale++; в update метода, променливата ще се увеличава с единица, с всеки един цикъл. По този начин и мащаба на началното изображение се увеличава и ефекта е постигнат. При стигане до определен мащаб, началната анимация приключва, таймера се включва и потребителя получава контрол над героя.</p>
<div class="code">
    <span class="Modifier">public</span>&nbsp;<span class="Type">void</span>&nbsp;round1Animation()<br />
    {<br />
    &nbsp;&nbsp;<span class="InlineComment">//round1&nbsp;animation&nbsp;and&nbsp;sound</span><br />
    &nbsp;&nbsp;<span class="Statement">if</span>&nbsp;(round1Bool)&nbsp;&nbsp;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;round1Scale&nbsp;+=&nbsp;4;<br />
    &nbsp;&nbsp;<span class="Statement">if</span>&nbsp;(round1Scale&nbsp;&gt;=&nbsp;100&nbsp;&amp;&amp;&nbsp;round1Scale&nbsp;&lt;=&nbsp;105&nbsp;&amp;&amp;&nbsp;Menu.soundOn)<br />
    &nbsp;&nbsp;&nbsp;&nbsp;round1Snd.play(1,&nbsp;Menu.soundVolume);<br />
    &nbsp;&nbsp;<span class="Statement">if</span>&nbsp;(round1Scale&nbsp;&gt;=&nbsp;600&nbsp;&amp;&amp;&nbsp;round1Scale&nbsp;&lt;=&nbsp;610)<br />
    &nbsp;&nbsp;{<br />
    &nbsp;&nbsp;&nbsp;&nbsp;round1Bool&nbsp;=&nbsp;<span class="Keyword">false</span>;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;enableInput&nbsp;=&nbsp;<span class="Keyword">true</span>;<br />
    &nbsp;&nbsp;&nbsp;&nbsp;round1Scale&nbsp;=&nbsp;1;<br />
    &nbsp;&nbsp;}<br />
    }
</div>
<p><span class="tab"></span>Методът е round1Animation(). round1Bool се грижи за приключването на анимацията. При достигане на размер 100 се включва съпътстващият звук, а при достигане на размер 600 анимацията приключва. Освен за началната анимация и звук, при изпълнението на метода се променя и трудността на противниците, според въведената настройка за трудност в менюто за настройки. enableInput булевата се използва за позволяване и забраняване на управлението на героя. Освен при началото на играта, булевата се използва и на други места, като по време на менюто за пауза.</p>
<h4>Карта на нивото</h4>
<p><span class="tab"></span>Картата представлява едно голямо изображение със зелен фон наподобяващ трева. Първо, изображението е оразмерено до точната големина, за да се получи достатъчно продължително ниво. Освен тревата имаме и гора, от горната и долната част. Тази гора представлява обструкция, която има за цел да не позволява на героя да излиза извън границите на нивото. Гората е изградена от един единствен спрайт на дърво. Спрайтът е взет от сайтът <a href="http://www.deviantart.com/" target="_blank"><b>www.deviantart.com</b></a> сайт за публикуване на произведения на изкуството, на потребители от цял свят.</p>
<img style="margin-left:auto;margin-right:auto;display:block;" src="/Resources/ryu7.png"><br />
<p>
    <span class="tab"></span>След намиране на подходящият спрайт, с помощта на Photoshop, дървото се дублира многократно, за да се постигне ефект на гора. Процесът по изграждането на нивото е сравнително лесен, но изображението трябва да е в .png формат, поради лимитация на slick2D. Това означава, че крайният резултат от картата е файл с размер от 10MB или близо 3 пъти по-голям от еквивалента си в .jpg формат.<br />
    <span class="tab"></span>При създаване на картата, създаваме и две променливи – shiftX и shiftY. Те се използват за да движат изображението в прозореца на програмата. Така когато движим героя, ние всъщност движим картата под него. Неговите координати си остават едни и същи, но получаваме ефект на движение на героя.
</p>
<h4>Създаване на Ryu</h4>
<p>
    <span class="tab"></span>За анимиране на главният герой на играта са използвани общо 14 различни анимации. Всяка една анимация е изградена от спрайтшийтове.<br/>
    <span class="tab"></span>Spritesheet представлява едно изображение, в което се намират няколко подизображения от анимацията наречени спрайтове.
</p>
<img style="margin-left:auto;margin-right:auto;display:block;" src="/Resources/ryu8.png"><br />
<p><span class="tab"></span>При декларацията използваме пътя към спрайт-изображението и x и y, които отговарят съответно за вертикалния и хоризонталния размер на кадъра в спрайта. И тук както при анимирането с отделни кадри, спрайта трябва да е в png формат и с прозрачен фон.</p>
<img style="margin-left:auto;margin-right:auto;display:block;" src="/Resources/ryu9.png"><br />
<p>
    <span class="tab"></span>Кадрите в спрайта трябва да са на точно разстояние един от друг. x се сформира като се вземе хоризонталната резолюция и се раздели на броят кадри в спрайта. При несъответствие, се получават неточности, в изобразяването на анимацията.<br />
    <span class="tab"></span>Анимацията се декларира, като за източник се използва спрайта, следван от х, отговарящ за времетраенето на всеки един кадър в милисекунди. След изтичане на времето, кадъра се заменя автоматично от следващия в спрайта.
</p>
<ul>
    <li><b>ryuStatic</b> - Това е статичната анимация. Използва се по всяко време, когато героят не се движи или не извършва някакво действие. Освен по време на игра, спрайтът се използва и в началното меню.</li>
    <li><b>ryuReady</b> - Анимацията се използва в началното и при благополучно приключване на играта. Тя представлява действието на Ryu, за завързване на лентата на главата си.</li>
    <li><b>ryuLeft</b> - Използва се при вървене назад и илюстрира отстъпване назад.</li>
    <li><b>ryuRight</b> - Използва се при движение напред/надясно, нагоре и надолу.</li>
    <li><b>ryuRight</b> - Това е юмрукът на Ryu.</li>
    <li><b>ryuLowKick</b> - Ритникът на Ryu.</li>
    <li><b>ryuHadoukenryuShoryuken</b> и <b>ryuTatsaku.</b> - Тези анимации илюстрират трите специални умения на героя.<b>ryuHadouken</b> се използва в комбинация с <b>ryuHadoukenBall</b>, която е анимацията на изстреляната от Ryu топка от енергия.</li>
    <li><b>ryuHurt</b> - Тази анимация илюстрира как Ryu поема удър от противник.</li>
    <li><b>ryuWin1</b> и <b>ryuWin2</b> - Това са две отделни анимации, които вървят в комбинация и се използват при благополучното приключване на играта. Те илюстрират Ryu като победител.</li>
</ul>
<p>
    <span class="tab"></span>Освен за визуализацията, Ryu използва и редица звукови ефекти, взети от различни източници от Интернет.<br />
    <span class="tab"></span>За реализацията на героя, са използвани и множество от променливи и методи, които вдъхват живот в него.
</p>
<p><span class="tab"></span>Методът ryuPhysics() отговаря за движението, привключването на различните анимации, ударите, специалните умения и жизнените показатели на главният герой. Методът слуша за въвеждания от клавиатурата и движи и илюстрира героя според тях. Тук са записани продължителностите на анимацийте, границите на нивото, които не могат да бъдат преминавани, взаимоотношението на Ryu с препядствията и обектите за събиране по картата и следенето на неговите жизнени показатели. За да се избегне дублирането на анимацийте, всяка една от тях е групирана със собствена булева стойност. Когато Ryu е в статично положение, булевата ryuStatic е true и всички останали са false. Във всеки един момент, само една булева стойност може да е истина. В противен случай, на картата могат да се появят две различни анимации едновременно или два главни героя един върху друг. За справяне с този проблем идва още един метод, наречен removeDuplications(). Той се грижи за това да има само една булева, която да е истина и променя останалите в неистина.</p>
<p><span class="tab"></span>Координатите на Ryu са описани от общо 4 променливи. Първите, shiftX и shiftY, определят местоположението му върху прозореца на играта. Тези координати са едни и същи и не се променят през цялата игра. Втората двойка променливи са ryuPositionX и ryuPositionY. Те определят местоположението му върху картата на нивото. Те описват движението на картата зад Ryu. Така получаваме ефекта, че Ryu се движи, но всъщност самата му фигура не се премества от горният ляв ъгъл на прозореца.</p>
<h4>Създаване на противниците</h4>
<p>
    <span class="tab"></span>Другата основна част от играта е създаването на противници, които да ни държат заети. Тяхната реализация е сходна с тази на главният герой – създадени са със спрайтове, издават звуци, имат жизнени показатели и могат да удрят. Разликата тук е, че те трябва да се контролират от компютъра, чрез изкуствен интелект (A.I.), вместо от клавиатурата.<br />
    <span class="tab"></span>Всеки един противник е създаден от 5 различни спрайта: статично положение, ходене, удряне, бивайки ударен и спрайт за умиране.
</p>
<img style="margin-left:auto;margin-right:auto;display:block;" src="/Resources/ryu10.png">
<p><span class="tab"></span>Противниците се намират на точно определени координати на нивото. За разлика от Ryu, противниците нямат специални умения следователно нямат магически точки (MP) а единствено здраве (HP), което се определя от зададеното ниво на трудност.</p>
<h4>Създаване на изкуствен интелект</h4>
<h5>Общи сведения</h5>
<p>
    <span class="tab"></span>Изкуственият интелект позволява на компютрите да правят неща, които за хората изглеждат разумни. Той има способност да анализира обкръжаващата го среда и да предприема действия, които увеличават възможността за постигане на определени цели.<br />
    <span class="tab"></span>Създаването на изкуственият интелект е един от най-сложните етапи, при проектирането на компютърна игра. За него има обособен отделен дял в информатиката и се изучава като академична дисциплина.<br />
    <span class="tab"></span>Пример за много добър A.I. е този в играта F.E.A.R.: First Encounter Assault Recon. Това е FPS шуутър, в който противниците имат широк набор от действия. Те могат да клякат и да минават под препядствия, да скачат през прозорци, да се подават през парапети, да изкачват стълби и да бутат обекти за да създадат прикритие от насрешната стрелба. Различни врагове могат да работят в екип, използвайки обиколни пътеки, за да изненадат играча в гръб, да използват потискаща стрелба и да скачат зад стени, когато биват обстрелвани. Често изкуственият интелект на F.E.A.R. е посочван като високо развит и неговата ефективност помага на играта да спечели наградите „2005 Best AI Award“ на GameSpot и „Most Infuental AI Games“ на AIGameDev's.<br />
    <span class="tab"></span>За целта на проекта е създаден по-просто устроен изкуствен интелект. Той е един и същ за всеки противник. Това което той прави е да следи за местоположението на главният герой, да се придвижва по посока към него и да изпълнява удари върху играча.<br />
    <span class="tab"></span>При започването на играта, всеки един противник е предварително създаден на нивото, но е в пасивно положение и ние не го виждаме. Те имат определен обхват на действие, в което Ryu трябва да влезне, за да могат да се активират. За да не се получи претрупване на врагове, на едно и също място, те се създадени със собствени уникални координати и обхвати на действие.<br />
    <span class="tab"></span>Обхватът е такъв, че когато противника се появи на екрана, той вече е в активно положение и вече се движи към нас. Веднъж задействан, противника ще е активен до края на жизненият си цикъл, който е до смъртта му, смъртта на Ryu или изтичане на времето.
</p>
<img style="margin-left:auto;margin-right:auto;display:block;" src="/Resources/ryu11.jpg"><br />

<span class="tab"></span><b>Source: <a href="https://github.com/ivanpop/Ryu">Github</a></b>
<span class="tab"></span><b>Download: <a href="~/Resources/ryu.zip" target="_blank">Link</a></b><br /><br />
<div class="text-center">
    <div class="pages">
        @Html.ActionLink(HttpUtility.HtmlDecode("&#8656;"), "Ryu", new { id = "" })
        @Html.ActionLink("1", "Ryu", new { id = "" })
        <div class="selected-page">
            <a href="#top">2</a>
        </div>
        @Html.ActionLink("3", "Ryu", new { id = 3 })
        @Html.ActionLink(HttpUtility.HtmlDecode("&#8658;"), "Ryu", new { id = 3 })
    </div>
</div>
<br />

<span class="tab"></span><a href="javascript:history.back()">&#8592; Обратно</a>